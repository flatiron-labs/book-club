## 3.9 Replace "string typing" with classes

##### Use case:
  - You're using specially formulated Strings to handle control flow with a case statement 

##### Implementation:
  - split that out into classes, yo!
  - instead of strings (which can have all sorts of formatting issues), use user-defined types
  - cases that vary (e.g. change light AND ring bell on yellow light) can be handled with additional methods in the subclass


##### Pros:
  - clearly defined interface that doesn't require additional case checks with new states added
  - better error handling (Ruby lets you know if you call a class that doesn't exist)
  - much cleaner interface in the TrafficLight class
  - don't have to worry about guarding the borders in the subclasses, the parent class handled that


##### Questions:
  - How do you know when you've found the right abstraction?
  - How early should you put in an abstraction like this?  You go from two easy to read case statements to multiple classes and polymorphism.  Is the code more clear at this point?


## 3.10 Wrap collaborators in Adapters

##### Use case:
  - You've got a wide arrange of input objects that don't have a common interface

##### Implementation:
  - create a wrapper that adapts the input object so that it has a common interface that you can use


##### Pros:
  - consistent interface across all of the input objects


##### Questions:
  - Should you always use a wrapper by default, just in case new inputs get added later?  Or is it better to wait until the first time you add a second set of inputs?


## 3.11 Use transparent adapters to gradually introduce abstraction

##### Use case:
  - You want to use an adapter, but, you inherited legacy code that has pre-existing dependencies on custom methods all over the place.


##### Implementation:
  - create a wrapper that serves as a 'transparent adapter'.  Anything that has the right interface to be handled by the adapter will be.  Everything else is passed through to the underlying classes with the custom methods.


##### Pros:
  - Improve quality of code incrementally, you don't have to do a huge overhaul all at once
    - New stuff follows a better pattern
    - Old stuff can be transitioned as there is time (or necessity)

##### Questions:
