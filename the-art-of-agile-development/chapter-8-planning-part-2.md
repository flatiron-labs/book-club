# Chapter 8: Planning (part 2)

## Iteration Planning

### Takeaways:

* We stop at predetermined, unchangeable time intervals and compare reality to plan.
* Iterations are the heartbeat of an XP project.
* Although the iteration timebox doesn’t prevent problems, it reveals them, which gives you the opportunity to correct the situation.
* Iteration schedule:
  - Demonstrate previous iteration (up to half an hour)
  - Hold retrospective on previous iteration (one hour) 
  - Plan iteration (half an hour to four hours)
    * Start by measuring the velocity of the previous iteration.
    * With your velocity in hand, you can select the stories to work on this iteration.
    * Because the iteration planning meeting takes stories from the front of the release plan, you should have already estimated and prioritized those stories.
    * After you have chosen the stories for the iteration, everybody but the programmers can leave the meeting, although anybody is welcome to stay if she likes.
    * At this point, the real work of iteration planning begins. Start by breaking down the stories into engineering tasks.
    * Brainstorming tasks is a design activity. If everybody has the same ideas about how to develop the software, it should go fairly quickly. If not, it’s a great opportunity for discussion before coding begins.
    * Finish brainstorming before you start estimating.
    * Call out the estimates as you finish them. If you hear somebody call out an estimate you disagree with, stop to discuss it and come to consensus.
    * Estimate the tasks in ideal hours.
    * As a final check, add up the estimates and compare them to the total task estimates from your previous iteration.
    * Discuss the situation with your on-site customers...adjust the plan until the team is ready to commit to delivering its stories.
  - Commit to delivering stories (five minutes) Develop stories (remainder of iteration)
    * Ask each person, in turn, if he can commit to doing so. Wait for a verbal “yes.”
  - Prepare release (less than 10 minutes)
    * At the end of the iteration, release your completed software to stakeholders. With a good 10-minute build, this shouldn’t require any more than a button press and a few minutes’ wait.
* When things go wrong
  - When you discover a problem that threatens your iteration commitment, first see if there’s any way you can change your plan so that you still meet your commitments.
  - Sometimes the problem will be too big to absorb. In this case, you’ll usually need to reduce the scope of the iteration.
  - Under no circumstances, however, should you change the iteration deadline.
  - After changing the plan, the customers should reestablish trust with stakeholders by explaining what happened, why, and what the team is doing to prevent this sort of problem in the future.
* Emergency requests
  - You can change the iteration schedule under the condition that you take out as much work as you add.
  - an emergency in every iteration means that something is wrong.
  - In some cases, however, the team has a legitimate need to provide ongoing support for ad hoc requests. If this is true for your team, sacrifice a programmer to be the batman.
  - Rotate a new programmer into the batman role every iteration to prevent burn-out.
* When you use iterations well, your team has a consistent, predictable velocity.
* Never artificially inflate your velocity. Similarly, don’t use commitment as a club. Never force team members to commit to a plan they don’t agree with.
* Energized work is also important. Without it, the team will have trouble maintaining equilibrium and a stable velocity.
* Iteration length:
  - Many teams prefer two-week iterations.
  - shorter iterations means more rapid improvement for a team new to XP.
  - One-week iterations also make decisions easier by reducing schedule risk.
  - one-week iterations put more pressure on the team.
  - Velocity is less stable in one-week iterations
  - Two-week iterations are a little less stressful and lead to a more stable velocity.

### Talking Points/Questions:

* How should we schedule time for fixing bugs?
* If we don’t estimate stories during iteration planning, when do we estimate stories?
* All the available tasks depend on tasks that other pairs are working on right now. What should I work on?
* What should the batman do when there are no outstanding support requests?


## Slack

### Takeaways:

### Talking Points/Questions:

## Stories

### Takeaways:

### Talking Points/Questions:

## Estimating

### Takeaways:

### Talking Points/Questions:
